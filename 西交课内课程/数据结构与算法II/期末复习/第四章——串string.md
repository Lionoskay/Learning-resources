## 第四章——串string

### 定义

串是零个或多个字符组成的有限序列

![image-20250621002124538](C:\Users\30606\AppData\Roaming\Typora\typora-user-images\image-20250621002124538.png)

![image-20250621002157710](C:\Users\30606\AppData\Roaming\Typora\typora-user-images\image-20250621002157710.png)

**注意：**串的元素序号从1开始数：a1,a2,a3......an，第i个位置的序号就是i

eg：有串：“hello world”，其子串“world”在主串中的位置是7

**注意：**串的数据元素可以为一个**字符**



### 串的各种操作的含义

#### 求串长——strlen

```c
int strlen(char *s)	//求出字符串s的长度
```

#### 串复制——strcpy

```c
char *strcpy(char *to,char *from)	//将字符串from复制给to并返回to的字符串首指针
```

#### 联接——strcat

```c
char *strcat(char *to,char *from)	//将串from复制到to的末尾
```

#### 串比较——strcmp

```c
int strcmp(char *s1,char *s2)	//比较串s1和s2的大小
```

#### 字符定位——strchr

```c
char* strchr(char *s,char c)	//在串s中找到字符c的位置并返回该位置
```

#### 串的定位——index

求子串在主串中第i个字符之后的位置

```c
int index(char *s,char *t,int i) //求子串s在主串t的第i个元素之后的主串中位置
    //方法：从主串s第i个元素位置开始，逐步取与子串t长度相等的串进行比较，找到后返回子串t在主串s中的位置
```



### 求子串的实现——substring

求子串通过字符串复制，将字符串中的子串部分复制到新串中

接收四个参数：新串，原主串，第几个元素开始，取几个字符

```c
void substring(char* sub,char* from,int pos,int len)
    eg: 
char *l1,*s;	//定义两个串
//s="hello world"
substring(l1,s,3,3)	//取串s的第三个元素开始，长度为1的字符复制到l1变成子串
//l1="llo"
```



例题：![image-20250621105527418](C:\Users\30606\AppData\Roaming\Typora\typora-user-images\image-20250621105527418.png)



### 存储结构

#### 定长顺序结构

直接使用定长的字符数组存放字符序列，静态分配空间，数组上界预先确定

```c
#define MAX_STRLEN 255
typedef char SString[MAX_STRLEN+1];	//提前声明一个静态存储空间，多一位放“\0”
```



#### 堆分配存储

动态存储分配的顺序表，本质是顺序表，其存储地址连续，但是动态分配存储空间大小

```c
typedef struct{
	char *elem;	//字符数组首地址位置，用malloc动态分配存储空间
	int length;	//字符数组长度，根据长度用malloc动态分配
}HString;
```



#### 块链存储

​	由于顺序串（使用顺序表存储的串）的插入删除不方便，使用链表存放串值，便于插入和删除元素，但是存储空间利用不完善

​	块链可以**自由决定**每个**结点中存放几个串元素**形成一个块链

![image-20250621110911132](C:\Users\30606\AppData\Roaming\Typora\typora-user-images\image-20250621110911132.png)

```c
#define NodeSize 10		//声明每个结点字符块大小，即存储几个字符
typedef struct	CNode{	//结点结构体
	char ch[NodeSize];	//每个结点字符块大小，数据域
    struct CNode* next;	//指针域
}CNode;
	
typedef struct{			//块链标签结构体
    CNode* head,*tail;	//标签中定位一个块链头指针和尾指针-》找到这个块链
    int curlen;			//标签中声明这个块链的长度
}CString;
```



### 串的模式匹配

#### 定义

1、**模式匹配**指子串的定位操作，求子串t在主串s中的位置，目的是在主串s中找到与t相同的子串

2、主串s称为目标，子串t称为模式

3、上文提及的**index()定位**就是一种模式匹配算法

#### 

#### BF算法——简单模式匹配

就是上文提到的index，在主串中逐步后移一个进行匹配

##### 时间复杂度分析：

假设子串t长度为m，主串长度为n，则最坏情况下需要比较：

1、每次比较m次

2、总共比较（n-m+1）次：加一是因为当n与m等长时也需要比较一次
$$
m*(n-m+1)
$$
则时间复杂度为	**O(n*m)**

![image-20250621112435366](C:\Users\30606\AppData\Roaming\Typora\typora-user-images\image-20250621112435366.png)



#### KMP算法——时间复杂度为O(n)

通过next数组确定下一次比较跳转的位置

##### next数组

next[j]表示当模式串中第j个字符与主串中的第i个字符匹配失败时，需要将模式串的哪个字符位置next[j]跳转到与主串第i个字符对齐进行匹配

![image-20250621130044492](C:\Users\30606\AppData\Roaming\Typora\typora-user-images\image-20250621130044492.png)

##### next数组的计算——根据模式串本身即可计算出

根据模式串中当前匹配位置j前的元素，找到前j-1个字符的最大公共前后缀大小i，那么next[j]值是i+1（即主串字符位置不变，模式串跳转到哪一个字符与这个主串字符比较）

eg：

| 位数                      | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串                    | a    | b    | c    | a    | b    | c    | c    |
| next值                    | 0    | 1    | 1    | 1    | 2    | 3    | 4    |
| 前j-1个字符最大前后缀相同 | 0    | 0    | 0    | 0    | 1    | 2    | 3    |

 匹配流程：

![9cec6027c1ef25427df5cc308b3e195a](E:\电脑管家迁移文件\微信聊天记录搬家\xwechat_files\wxid_f8u7hyaq9ysa22_f149\temp\2025-06\RWTemp\c1f4f4c15ddbc3857c595549d94698de\9cec6027c1ef25427df5cc308b3e195a.jpg)

eg：

| 序号                    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串                  | a    | b    | a    | b    | a    | b    | b    |
| 前j-1字符最大公共前后缀 | 0    | 0    | 0    | 1    | 2    | 3    | 4    |
| next[j]                 | 0    | 1    | 1    | 2    | 3    | 4    | 5    |

**注意**：前后缀是**真子串**，不能完全等于子串但是**可以重叠计算**

eg：ababa

前缀：a,ab,aba,abab

后缀：a,ba,aba,baba

最大公共前后缀：aba

#### nextval数组——next数组的修正

作用是跳过next数组中必然匹配失败的位置（**当前字符已经不匹配，若跳转位置的字符与当前位置字符相等，必然不匹配，需要跳过......进行递归操作**），节省比较次数

**实质**是：提前将当前主模串比较位置的字符与模式串跳转位置的字符进行比较，若相等则直接跳转到当前跳转位置字符的跳转字符位置，若不相等就只跳到当前跳转字符位置

nextval字符存储的位置仍是模式串与主串对齐的位置

| 位数                      | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串                    | a    | b    | c    | a    | b    | c    | c    |
| next值                    | 0    | 1    | 1    | 1    | 2    | 3    | 4    |
| 前j-1个字符最大前后缀相同 | 0    | 0    | 0    | 0    | 1    | 2    | 3    |
| nextval值                 | 0    | 1    | 1    | 0    | 1    | 1    | 4    |

即：

1、若当前字符j与跳转后next[j]处的字符**相等**——》继续跳转到next[j]字符的next[next[j]]位置，**nextval[j]=next[next[j]]**，若仍相等则继续递归跳转

2、若当前字符j与跳转后next[j]处的字符**不相等**——》只跳转到next[j]位置，nextval[j]=next[j]

![02b4567150120e6647298d59fc9a4cd5](E:\电脑管家迁移文件\微信聊天记录搬家\xwechat_files\wxid_f8u7hyaq9ysa22_f149\temp\2025-06\RWTemp\c1f4f4c15ddbc3857c595549d94698de\02b4567150120e6647298d59fc9a4cd5.jpg)

eg：

| 序号                    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串                  | a    | b    | a    | b    | a    | b    | b    |
| 前j-1字符最大公共前后缀 | 0    | 0    | 0    | 1    | 2    | 3    | 4    |
| next[j]                 | 0    | 1    | 1    | 2    | 3    | 4    | 5    |
| nextval[j]              | 0    | 1    | 0    | 1    | 0    | 1    | 5    |

其中6的b跳转到4，相等，需要跳转到2，仍相等，继续跳转到1